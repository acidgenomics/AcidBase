% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/realpath.R
\name{realpath}
\alias{realpath}
\title{Express file paths in canonical form}
\usage{
realpath(path)
}
\arguments{
\item{path}{character vector of file paths.}
}
\value{
A character vector.

  If an input is not a real path the result is system-dependent (unless
  \code{mustWork = TRUE}, when this should be an error).  It will be
  either the corresponding input element or a transformation of it into
  an absolute path.

  Converting to an absolute file path can fail for a large number of
  reasons.  The most common are
  \itemize{
    \item One of more components of the file path does not exist.
    \item A component before the last is not a directory, or there is
    insufficient permission to read the directory.
    \item For a relative path, the current directory cannot be
    determined.
    \item A symbolic link points to a non-existent place or links form a
    loop.
    \item The canonicalized path would be exceed the maximum supported
    length of a file path.
  }
}
\description{
Convert file paths to canonical form for the platform, to display them
  in a user-understandable form and so that relative and absolute paths can
  be compared.
}
\details{
Tilde-expansion (see \code{\link[base]{path.expand}}) is first done on
  \code{paths}.

  Where the Unix-alike platform supports it attempts to turn paths into
  absolute paths in their canonical form (no \samp{./}, \samp{../} nor
  symbolic links).  It relies on the POSIX system function
  \code{realpath}: if the platform does not have that (we know of no
  current example) then the result will be an absolute path but might
  not be canonical.  Even where \code{realpath} is used the canonical
  path need not be unique, for example \emph{via} hard links or
  multiple mounts.

  On Windows it converts relative paths to absolute paths, resolves symbolic
  links, converts short names for path elements to long names and ensures the
  separator is that specified by \code{winslash}.  It will match each path
  element case-insensitively or case-sensitively as during the usual name
  lookup and return the canonical case. It relies on Windows API function
  \code{GetFinalPathNameByHandle} and in case of an error (such as
  insufficient permissions) it currently falls back to the \R 3.6 (and
  older) implementation, which relies on \code{GetFullPathName} and
  \code{GetLongPathName} with limitations described in the Notes section.
  An attempt is made not to introduce UNC paths in presence of mapped drives
  or symbolic links: if \code{GetFinalPathNameByHandle} returns a UNC path,
  but \code{GetLongPathName} returns a path starting with a drive letter, R
  falls back to the \R 3.6 (and older) implementation.
  UTF-8-encoded paths not valid in the current locale can be used.

  \code{mustWork = FALSE} is useful for expressing paths for use in
  messages.
}
\note{
Updated 2019-10-22.
}
\examples{
realpath(".")
normalizePath(".")
}
\seealso{
Standard path modifiers:
\itemize{
\item \code{normalizePath()}.
\item \code{file.path()}.
}

Checking for existence, access:
\itemize{
\item \code{file.access()}.
\item \code{file.exists()}.
\item \code{goalie::hasAccess()}.
\item \code{goalie::allHaveAccess()}.
}
}
