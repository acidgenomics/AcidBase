% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/shell.R
\name{shell}
\alias{shell}
\title{Invoke a command in the system command-line shell}
\usage{
shell(
  command,
  args = character(),
  print = interactive(),
  wd = getwd(),
  stderrFile = NULL,
  stdoutFile = NULL,
  stderrToStdout = FALSE,
  returnStdout = FALSE
)
}
\arguments{
\item{command}{\code{character(1)}.
Name of program to run.}

\item{args}{\code{character}.
Arguments passed to \code{command}.}

\item{print}{\code{logical(1)}.
Whether to print (echo) the commands to the console.}

\item{wd}{\code{character(1)}.
Working directory path inside shell session.}

\item{stdoutFile, stderrFile}{\code{character(1)} or \code{NULL}.
File path to log stdout and/or stderr.
Disabled when set \code{NULL}.}

\item{stderrToStdout}{\code{logical(1)}.
Whether to redirect standard error (stderr) to standard output (stdout).
Similar to \verb{2>&1} in POSIX or \verb{&>} in Bash.}

\item{returnStdout}{\code{logical(1)}.
Whether to return stdout as a character vector, split by \code{"\\n"}.}
}
\value{
Invisible \code{list}.
Contains named elements:
\code{"status"}, \code{"stdout"}, \code{"stderr"}, \code{"timeout"}.
}
\description{
Invoke a command in the system command-line shell
}
\note{
Updated 2022-05-02.
}
\examples{
x <- shell(
    command = "printf",
    args = c("\%s\n", "hello", "world"),
    print = TRUE
)
print(x)
}
\seealso{
\itemize{
\item \code{processx::run()}.
\item \code{base::system2()}, our previously used legacy approach.
}
}
