% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/strSplit.R
\name{strSplit}
\alias{strSplit}
\title{Split the elements of a character vector into a matrix}
\usage{
strSplit(x, split, fixed = TRUE, n = Inf)
}
\arguments{
\item{x}{\code{character}.
Character vector that does not contain \code{NA} or empty strings.}

\item{split}{\code{character(1)}.
String that defines the split boundary. The number of characters (\code{nchar})
can be greater than 1 here. Regular expressions are intentionally not
supported to keep this simple.}

\item{fixed}{\code{logical(1)}.
If \code{TRUE}, \code{pattern} is a string to be matched as is.
Otherwise, will match by regular expression.}

\item{n}{\code{Inf} or \code{integer(1)}.
Maximum number of strings to return. If \code{Inf}, return all strings defined
by split boundary. When set, function will split up to this number.}
}
\value{
\code{matrix}.
Character matrix split into columns.
}
\description{
Split the elements of a character vector into a matrix
}
\note{
Updated 2023-09-22.
}
\examples{
## Infinite number of fixed splits.
x <- c("a__b__c", "d__e__f", "g__h__i")
mat <- strSplit(x = x, split = "__", fixed = TRUE, n = Inf)
print(mat)

## Infinite number of regex splits.
x <- c("a_b_c_d", "e_f__g___h", "i__j__k__l")
mat <- strSplit(x = x, split = "_+", fixed = FALSE, n = Inf)
print(mat)

## Finite number of fixed splits.
x <- c("a__b__c", "d__e__f", "g__h__i")
mat <- strSplit(x = x, split = "__", fixed = TRUE, n = 2L)
print(mat)

## Finite number of regex splits.
x <- c("a_b_c_d", "e_f__g___h", "i__j__k__l")
mat <- strSplit(x = x, split = "_+", fixed = FALSE, n = 2L)
print(mat)
}
\seealso{
\itemize{
\item Infinite splits: \code{\link[=strsplit]{strsplit()}}.
\item Finite splits: \code{\link[=gregexpr]{gregexpr()}}, \code{\link[=substr]{substr()}}.
\item \code{\link[stringi:stri_split]{stringi::stri_split_fixed()}}.
\item \code{\link[stringr:str_split]{stringr::str_split_fixed()}}.
}
}
